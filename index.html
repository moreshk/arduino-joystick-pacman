<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Joystick Pacman</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Press Start 2P', cursive, Arial, sans-serif;
    }
    
    #game-container {
      position: relative;
      margin: 20px auto;
      width: 800px;
      height: 600px;
    }
    
    #canvas {
      display: block;
      margin: 0 auto;
      background-color: #000;
    }
    
    #connect {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 16px;
      font-size: 16px;
      z-index: 10;
      background-color: #FFD700;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
    }
    
    #connect:hover {
      background-color: #FFC107;
    }
    
    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #life {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 30px;
      z-index: 5;
    }
    
    #controls {
      position: absolute;
      bottom: 10px;
      right: 10px;
      color: #FFD700;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .control-label {
      font-size: 16px;
    }
    
    .control-btn {
      padding: 5px 10px;
      background-color: #FFD700;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
      font-size: 12px;
    }
    
    .control-btn:hover {
      background-color: #FFC107;
    }
    
    #pause-btn {
      padding: 5px 10px;
      background-color: #FFD700;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
      font-size: 14px;
      margin-top: 5px;
    }
    
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 36px;
      z-index: 15;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <div id="game-container">
    <button id="connect">Connect Joystick</button>
    <div id="score">Score: 0</div>
    <div id="life">Lives: 3</div>
    <div id="loading">Loading...</div>
    <div id="controls">
      <div class="control-group">
        <span class="control-label">Speed:</span>
        <button class="control-btn" id="speed-down">-</button>
        <span id="speed-value">Normal</span>
        <button class="control-btn" id="speed-up">+</button>
      </div>
      <button id="pause-btn">Pause</button>
    </div>
    <div id="message">Paused<br><span style="font-size: 18px">Press Pause or Joystick Button to Resume</span></div>
    <canvas id="canvas" width="800" height="600"></canvas>
  </div>

  <script>
    // Game canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const lifeElement = document.getElementById('life');
    const loadingElement = document.getElementById('loading');
    const messageElement = document.getElementById('message');
    const speedValueElement = document.getElementById('speed-value');
    
    // Game state
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let gameOver = false;
    let gamePaused = false;
    
    // Frame rate control
    const TARGET_FPS = 30;  // Lower FPS for more controlled gameplay
    let lastFrameTime = 0;
    const MIN_FRAME_TIME = 1000 / TARGET_FPS;
    
    // Speed control
    const speedLevels = [
      { name: "Very Slow", factor: 0.25 },
      { name: "Slow", factor: 0.4 },
      { name: "Normal", factor: 0.6 },
      { name: "Fast", factor: 0.8 },
      { name: "Very Fast", factor: 1.0 }
    ];
    let currentSpeedIndex = 0; // Start at Very Slow speed
    let speedFactor = speedLevels[currentSpeedIndex].factor;
    
    // Base speeds that will be multiplied by the speed factor
    const BASE_PACMAN_SPEED = 1.0;  // Reduced from 1.5 to 1.0
    const BASE_GHOST_SPEEDS = [0.5, 0.45, 0.4, 0.35];  // Reduced ghost speeds by half
    
    // Joystick variables
    let joystickX = 0, joystickY = 0;
    let joystickButton = 0;
    let joystickDirection = { x: 0, y: 0 };
    let reader;
    let buffer = '';
    
    // Sound effects
    const audioPaths = {
      chomp: 'sounds/pacman_chomp.mp3',
      death: 'sounds/pacman_death.mp3',
      eatGhost: 'sounds/pacman_eatghost.mp3',
      eatFruit: 'sounds/pacman_eatfruit.mp3',
      powerPill: 'sounds/pacman_powerpill.mp3',
      start: 'sounds/pacman_beginning.mp3'
    };
    
    const sounds = {};
    
    // Pacman properties
    const pacman = {
      x: 400,
      y: 300,
      radius: 20,
      speed: BASE_PACMAN_SPEED,
      angle: 0,
      direction: { x: 1, y: 0 },
      nextDirection: { x: 1, y: 0 },
      mouthOpen: 0,
      mouthSpeed: 0.02  // Reduced from 0.04 to 0.02 for slower animation
    };
    
    // Create maze walls - simplified for this demo
    const walls = [
      // Outer walls
      { x: 0, y: 0, width: 800, height: 40 },
      { x: 0, y: 560, width: 800, height: 40 },
      { x: 0, y: 0, width: 40, height: 600 },
      { x: 760, y: 0, width: 40, height: 600 },
      
      // Inner walls - horizontal
      { x: 120, y: 120, width: 200, height: 40 },
      { x: 400, y: 120, width: 280, height: 40 },
      { x: 120, y: 240, width: 200, height: 40 },
      { x: 400, y: 240, width: 280, height: 40 },
      { x: 120, y: 360, width: 560, height: 40 },
      { x: 120, y: 480, width: 200, height: 40 },
      { x: 400, y: 480, width: 280, height: 40 },
      
      // Inner walls - vertical
      { x: 120, y: 120, width: 40, height: 400 },
      { x: 280, y: 120, width: 40, height: 160 },
      { x: 400, y: 120, width: 40, height: 160 },
      { x: 640, y: 120, width: 40, height: 160 },
      { x: 280, y: 360, width: 40, height: 160 },
      { x: 400, y: 360, width: 40, height: 160 },
      { x: 640, y: 360, width: 40, height: 160 }
    ];
    
    // Dots for Pacman to eat
    let dots = [];
    const dotSize = 6;
    const dotSpacing = 40;
    
    // Ghosts
    const ghosts = [
      { x: 120, y: 120, color: 'red', speed: BASE_GHOST_SPEEDS[0], direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 120, color: 'pink', speed: BASE_GHOST_SPEEDS[1], direction: { x: -1, y: 0 }, state: 'normal' },
      { x: 120, y: 480, color: 'cyan', speed: BASE_GHOST_SPEEDS[2], direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 480, color: 'orange', speed: BASE_GHOST_SPEEDS[3], direction: { x: -1, y: 0 }, state: 'normal' }
    ];
    
    // Power pills
    const powerPills = [
      { x: 80, y: 80, radius: 10, active: true },
      { x: 720, y: 80, radius: 10, active: true },
      { x: 80, y: 520, radius: 10, active: true },
      { x: 720, y: 520, radius: 10, active: true }
    ];
    
    // Create dots throughout the maze
    function createDots() {
      dots = [];
      for (let x = 60; x < canvas.width; x += dotSpacing) {
        for (let y = 60; y < canvas.height; y += dotSpacing) {
          // Check if the dot is inside a wall
          let insideWall = false;
          
          for (const wall of walls) {
            if (
              x >= wall.x && 
              x <= wall.x + wall.width && 
              y >= wall.y && 
              y <= wall.y + wall.height
            ) {
              insideWall = true;
              break;
            }
          }
          
          // Only add dots that are not inside walls
          if (!insideWall) {
            dots.push({ x, y, active: true });
          }
        }
      }
    }

    // Generate a random direction for ghosts
    function getRandomDirection() {
      const directions = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];
      return directions[Math.floor(Math.random() * directions.length)];
    }
    
    // Check collision between circles (for Pacman-ghost collision)
    function circleCollision(circle1, circle2, radius1, radius2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < radius1 + radius2;
    }
    
    // Check collision between circle and rectangle (for wall collisions)
    function circleRectCollision(circle, rect, radius) {
      // Find the closest point in the rectangle to the circle
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
      
      // Calculate the distance between the circle's center and the closest point
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If the distance is less than the circle's radius, there is a collision
      return distance < radius;
    }
    
    // Update direction based on joystick input
    function updateJoystickDirection() {
      // Threshold to detect significant joystick movement
      const threshold = 0.2;
      
      // Reset the direction object
      joystickDirection = { x: 0, y: 0 };
      
      // Determine the direction based on joystick values
      if (Math.abs(joystickX) > Math.abs(joystickY)) {
        // Horizontal movement has priority
        if (joystickX > threshold) {
          joystickDirection.x = 1;
          joystickDirection.y = 0;  // Ensure only one direction
        } else if (joystickX < -threshold) {
          joystickDirection.x = -1;
          joystickDirection.y = 0;  // Ensure only one direction
        }
      } else {
        // Vertical movement has priority
        if (joystickY > threshold) {
          joystickDirection.y = 1;
          joystickDirection.x = 0;  // Ensure only one direction
        } else if (joystickY < -threshold) {
          joystickDirection.y = -1;
          joystickDirection.x = 0;  // Ensure only one direction
        }
      }
      
      // Update Pacman's next direction if joystick has input
      if (joystickDirection.x !== 0 || joystickDirection.y !== 0) {
        pacman.nextDirection = { ...joystickDirection };
      }
    }
    
    // Move Pacman
    function movePacman() {
      // Apply speed factor to Pacman's movement
      const adjustedSpeed = pacman.speed * speedFactor;
      
      // Calculate next position
      let nextX = pacman.x + pacman.direction.x * adjustedSpeed;
      let nextY = pacman.y + pacman.direction.y * adjustedSpeed;
      
      // Check if Pacman can move in the current direction
      let canMove = true;
      for (const wall of walls) {
        if (circleRectCollision(
          { x: nextX, y: nextY }, 
          wall, 
          pacman.radius - 1 // Slightly smaller to allow smoother movement
        )) {
          canMove = false;
          break;
        }
      }
      
      // If Pacman can move in the current direction, update position
      if (canMove) {
        pacman.x = nextX;
        pacman.y = nextY;
      } else {
        // If Pacman cannot move in the current direction, try to change to the next direction
        const newDirNextX = pacman.x + pacman.nextDirection.x * adjustedSpeed;
        const newDirNextY = pacman.y + pacman.nextDirection.y * adjustedSpeed;
        
        let canChangeDirection = true;
        for (const wall of walls) {
          if (circleRectCollision(
            { x: newDirNextX, y: newDirNextY }, 
            wall, 
            pacman.radius - 1
          )) {
            canChangeDirection = false;
            break;
          }
        }
        
        if (canChangeDirection) {
          pacman.direction = { ...pacman.nextDirection };
          pacman.x = newDirNextX;
          pacman.y = newDirNextY;
        }
      }
      
      // Update angle based on direction
      if (pacman.direction.x === 1) pacman.angle = 0;
      else if (pacman.direction.x === -1) pacman.angle = Math.PI;
      else if (pacman.direction.y === -1) pacman.angle = -Math.PI / 2;
      else if (pacman.direction.y === 1) pacman.angle = Math.PI / 2;
      
      // Update mouth animation
      pacman.mouthOpen += pacman.mouthSpeed;
      if (pacman.mouthOpen > 0.5 || pacman.mouthOpen < 0) {
        pacman.mouthSpeed = -pacman.mouthSpeed;
      }
      
      // Check for dot collisions
      for (let i = 0; i < dots.length; i++) {
        if (dots[i].active && circleCollision(pacman, dots[i], pacman.radius, dotSize)) {
          dots[i].active = false;
          score += 10;
          scoreElement.textContent = `Score: ${score}`;
          playSound('chomp');
        }
      }
      
      // Check for power pill collisions
      for (const pill of powerPills) {
        if (pill.active && circleCollision(pacman, pill, pacman.radius, pill.radius)) {
          pill.active = false;
          score += 50;
          scoreElement.textContent = `Score: ${score}`;
          playSound('powerPill');
          
          // Make ghosts vulnerable
          for (const ghost of ghosts) {
            ghost.state = 'vulnerable';
            ghost.vulnerableTimer = 500; // About 8 seconds at 60 FPS
          }
        }
      }
      
      // Handle screen wrapping
      if (pacman.x < -pacman.radius) pacman.x = canvas.width + pacman.radius;
      if (pacman.x > canvas.width + pacman.radius) pacman.x = -pacman.radius;
      if (pacman.y < -pacman.radius) pacman.y = canvas.height + pacman.radius;
      if (pacman.y > canvas.height + pacman.radius) pacman.y = -pacman.radius;
    }
    
    // Move ghosts
    function moveGhosts() {
      for (const ghost of ghosts) {
        // Reduce vulnerable timer if vulnerable
        if (ghost.state === 'vulnerable' && ghost.vulnerableTimer > 0) {
          ghost.vulnerableTimer--;
          if (ghost.vulnerableTimer === 0) {
            ghost.state = 'normal';
          }
        }
        
        // Decide whether to chase Pacman or move randomly
        if (ghost.state === 'normal' && Math.random() < 0.02) {  // 2% chance per frame to update direction
          // 60% chance to chase Pacman, 40% chance for random movement
          if (Math.random() < 0.6) {
            // Chase Pacman - determine best direction to move towards Pacman
            let bestDirection = { x: 0, y: 0 };
            
            // Calculate direction to Pacman
            const dx = pacman.x - ghost.x;
            const dy = pacman.y - ghost.y;
            
            // Choose primary direction based on distance
            if (Math.abs(dx) > Math.abs(dy)) {
              // Horizontal distance is greater
              bestDirection.x = dx > 0 ? 1 : -1;
              bestDirection.y = 0;
            } else {
              // Vertical distance is greater
              bestDirection.x = 0;
              bestDirection.y = dy > 0 ? 1 : -1;
            }
            
            ghost.direction = bestDirection;
          } else {
            // Random movement
            ghost.direction = getRandomDirection();
          }
        } else if (ghost.state === 'vulnerable' && Math.random() < 0.03) {  // Vulnerable ghosts change direction more often
          // When vulnerable, try to move away from Pacman
          const dx = pacman.x - ghost.x;
          const dy = pacman.y - ghost.y;
          
          // Choose direction away from Pacman
          if (Math.abs(dx) > Math.abs(dy)) {
            ghost.direction = { x: dx > 0 ? -1 : 1, y: 0 };
          } else {
            ghost.direction = { x: 0, y: dy > 0 ? -1 : 1 };
          }
        }
        
        // Apply speed factor to ghost movement
        const adjustedSpeed = ghost.speed * speedFactor * (ghost.state === 'vulnerable' ? 0.5 : 1);
        
        // Move ghost with the adjusted speed
        let nextX = ghost.x + ghost.direction.x * adjustedSpeed;
        let nextY = ghost.y + ghost.direction.y * adjustedSpeed;
        
        // Check for wall collisions
        let hitWall = false;
        for (const wall of walls) {
          if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
            hitWall = true;
            break;
          }
        }
        
        if (hitWall) {
          // Change direction if hit a wall
          // Try multiple directions until finding a valid one
          let foundValidDirection = false;
          let attempts = 0;
          const maxAttempts = 4;  // Try all four directions
          
          while (!foundValidDirection && attempts < maxAttempts) {
            attempts++;
            ghost.direction = getRandomDirection();
            
            nextX = ghost.x + ghost.direction.x * adjustedSpeed;
            nextY = ghost.y + ghost.direction.y * adjustedSpeed;
            
            // Check if the new direction is valid
            let validDirection = true;
            for (const wall of walls) {
              if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
                validDirection = false;
                break;
              }
            }
            
            if (validDirection) {
              foundValidDirection = true;
            }
          }
          
          // If all directions are blocked, just stay put for this frame
          if (!foundValidDirection) {
            nextX = ghost.x;
            nextY = ghost.y;
          }
        } else {
          ghost.x = nextX;
          ghost.y = nextY;
          
          // Handle screen wrapping
          if (ghost.x < -20) ghost.x = canvas.width + 20;
          if (ghost.x > canvas.width + 20) ghost.x = -20;
          if (ghost.y < -20) ghost.y = canvas.height + 20;
          if (ghost.y > canvas.height + 20) ghost.y = -20;
        }
        
        // Check for collision with Pacman
        if (circleCollision(pacman, ghost, pacman.radius - 5, pacman.radius - 5)) {
          if (ghost.state === 'vulnerable') {
            // Pacman eats ghost
            ghost.x = 400;
            ghost.y = 300;
            ghost.state = 'normal';
            score += 200;
            scoreElement.textContent = `Score: ${score}`;
            playSound('eatGhost');
          } else if (ghost.state === 'normal') {
            // Ghost catches Pacman
            lives--;
            lifeElement.textContent = `Lives: ${lives}`;
            playSound('death');
            
            if (lives <= 0) {
              gameOver = true;
            } else {
              // Reset positions
              resetPositions();
            }
          }
        }
      }
    }
    
    // Reset positions after losing a life
    function resetPositions() {
      pacman.x = 400;
      pacman.y = 300;
      pacman.direction = { x: 1, y: 0 };
      pacman.nextDirection = { x: 1, y: 0 };
      
      // Reset ghost positions and directions
      ghosts[0].x = 120;
      ghosts[0].y = 120;
      ghosts[0].direction = { x: 1, y: 0 };
      
      ghosts[1].x = 680;
      ghosts[1].y = 120;
      ghosts[1].direction = { x: -1, y: 0 };
      
      ghosts[2].x = 120;
      ghosts[2].y = 480;
      ghosts[2].direction = { x: 1, y: 0 };
      
      ghosts[3].x = 680;
      ghosts[3].y = 480;
      ghosts[3].direction = { x: -1, y: 0 };
      
      // Short pause to acknowledge death
      gameRunning = false;
      setTimeout(() => {
        gameRunning = true;
        // No need to call gameLoop here since requestAnimationFrame is already running
      }, 1500);  // Increased from 1000 to 1500ms for a longer pause
    }
    
    // Draw the game
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw walls
      ctx.fillStyle = '#0000AA';
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      
      // Draw dots
      ctx.fillStyle = '#FFFF00';
      for (const dot of dots) {
        if (dot.active) {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw power pills
      ctx.fillStyle = '#FFFF00';
      for (const pill of powerPills) {
        if (pill.active) {
          ctx.beginPath();
          ctx.arc(pill.x, pill.y, pill.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw Pacman
      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();
      ctx.arc(
        pacman.x, 
        pacman.y, 
        pacman.radius, 
        pacman.angle + pacman.mouthOpen * Math.PI, 
        pacman.angle + (2 - pacman.mouthOpen) * Math.PI
      );
      ctx.lineTo(pacman.x, pacman.y);
      ctx.fill();
      
      // Draw ghosts
      for (const ghost of ghosts) {
        if (ghost.state === 'vulnerable') {
          // Blinking effect when vulnerability is about to end
          if (ghost.vulnerableTimer < 100 && Math.floor(ghost.vulnerableTimer / 10) % 2 === 0) {
            ctx.fillStyle = '#FFFFFF';
          } else {
            ctx.fillStyle = '#0000FF';
          }
        } else {
          ctx.fillStyle = ghost.color;
        }
        
        // Draw ghost body
        ctx.beginPath();
        ctx.arc(ghost.x, ghost.y, pacman.radius - 2, Math.PI, 0, false);
        ctx.lineTo(ghost.x + (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        
        // Draw the wavy bottom
        const segments = 3;
        const segmentWidth = (pacman.radius * 2 - 4) / segments;
        
        for (let i = 0; i < segments; i++) {
          const segX = ghost.x + (pacman.radius - 2) - (i * segmentWidth);
          ctx.arc(segX - (segmentWidth/2), ghost.y + (pacman.radius - 2), segmentWidth/2, 0, Math.PI, true);
        }
        
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y);
        ctx.fill();
        
        // Draw ghost eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(ghost.x - 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw pupils
        ctx.fillStyle = '#000000';
        const pupilX = ghost.direction.x * 2;
        const pupilY = ghost.direction.y * 2;
        
        ctx.beginPath();
        ctx.arc(ghost.x - 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw game over message
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '48px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText('Reconnect joystick to play again', canvas.width / 2, canvas.height / 2 + 90);
      }
      
      // Check if all dots are eaten
      const remainingDots = dots.filter(dot => dot.active).length;
      const remainingPills = powerPills.filter(pill => pill.active).length;
      
      if (remainingDots === 0 && remainingPills === 0) {
        // Level completed
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '36px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        if (!gameOver) {
          // Reset game for next level
          setTimeout(() => {
            createDots();
            for (const pill of powerPills) {
              pill.active = true;
            }
            resetPositions();
          }, 3000);
        }
      }
    }
    
    // Load and play sounds
    function loadSounds() {
      for (const [name, path] of Object.entries(audioPaths)) {
        sounds[name] = new Audio(path);
      }
    }
    
    function playSound(name) {
      if (sounds[name]) {
        // Stop the sound if it's currently playing
        sounds[name].pause();
        sounds[name].currentTime = 0;
        
        // Play the sound
        sounds[name].play().catch(error => {
          console.error(`Error playing sound ${name}:`, error);
        });
      }
    }
    
    // Main game loop
    function gameLoop(timestamp) {
      if (!gameRunning || gameOver || gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Limit frame rate for more consistent speed
      const elapsed = timestamp - lastFrameTime;
      if (elapsed < MIN_FRAME_TIME) {
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Update last frame time
      lastFrameTime = timestamp;
      
      updateJoystickDirection();
      movePacman();
      moveGhosts();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Initialize the game
    function initGame() {
      createDots();
      loadSounds();
      
      // Start the game when assets are loaded
      window.addEventListener('load', () => {
        loadingElement.style.display = 'none';
        gameRunning = true;
        playSound('start');
        
        // Start game loop with timestamp
        requestAnimationFrame(gameLoop);
      });
    }
    
    // — Ask user to pick the Arduino serial port —
    async function connectSerial() {
      try {
        const port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        console.log('Serial port opened');
        
        // Reset game state for new game
        score = 0;
        lives = 3;
        gameOver = false;
        scoreElement.textContent = `Score: ${score}`;
        lifeElement.textContent = `Lives: ${lives}`;
        createDots();
        resetPositions();
        
        // Start reading serial data
        readSerialData();
        
        // If the game is not running, start it
        if (!gameRunning) {
          gameRunning = true;
          playSound('start');
          gameLoop();
        }
      } catch(err) {
        console.error('Serial connection failed:', err);
      }
    }
    document.getElementById('connect').addEventListener('click', connectSerial);

    // Handle serial data reading separately from animation loop
    async function readSerialData() {
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            reader.releaseLock();
            break;
          }
          
          // Add to buffer and process complete lines
          buffer += value;
          const lines = buffer.split('\n');
          buffer = lines.pop(); // Keep the last incomplete line in buffer
          
          // Process complete lines
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed) {
              const parts = trimmed.split(',').map(Number);
              // Check if we have at least X and Y values
              if (parts.length >= 2 && !isNaN(parts[0]) && !isNaN(parts[1])) {
                // normalize to -1…1 with lower sensitivity
                const newJoystickX = (parts[0] - 512) / 512 * 0.8;
                const newJoystickY = (parts[1] - 512) / 512 * 0.8;
                
                // Apply a larger deadzone to prevent small joystick noise
                joystickX = Math.abs(newJoystickX) < 0.15 ? 0 : newJoystickX;
                joystickY = Math.abs(newJoystickY) < 0.15 ? 0 : newJoystickY;
                
                // Check for button press if available
                if (parts.length >= 3 && !isNaN(parts[2])) {
                  // If button state changed from 0 to 1, toggle pause
                  if (parts[2] === 1 && joystickButton === 0) {
                    togglePause();
                  }
                  joystickButton = parts[2];
                }
              }
            }
          }
        }
      } catch (error) {
        console.error('Error reading serial data:', error);
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      // Keep the game proportional
      const container = document.getElementById('game-container');
      const aspectRatio = canvas.width / canvas.height;
      
      let newWidth = window.innerWidth * 0.8;
      let newHeight = newWidth / aspectRatio;
      
      if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight * aspectRatio;
      }
      
      container.style.width = `${newWidth}px`;
      container.style.height = `${newHeight}px`;
    });
    
    // Function to toggle game pause state
    function togglePause() {
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        messageElement.style.display = 'block';
      } else {
        messageElement.style.display = 'none';
        // Restart the game loop if unpausing
        if (gameRunning && !gameOver) {
          gameLoop();
        }
      }
    }
    
    // Function to change game speed
    function changeSpeed(direction) {
      // direction: 1 = faster, -1 = slower
      currentSpeedIndex = Math.max(0, Math.min(speedLevels.length - 1, currentSpeedIndex + direction));
      speedFactor = speedLevels[currentSpeedIndex].factor;
      speedValueElement.textContent = speedLevels[currentSpeedIndex].name;
    }
    
    // Set up control buttons
    document.getElementById('speed-up').addEventListener('click', () => changeSpeed(1));
    document.getElementById('speed-down').addEventListener('click', () => changeSpeed(-1));
    document.getElementById('pause-btn').addEventListener('click', togglePause);
    
    // Add keyboard controls for testing without Arduino
    window.addEventListener('keydown', (e) => {
      if (gameRunning && !gamePaused) {
        switch (e.key) {
          case 'ArrowUp':
            pacman.nextDirection = { x: 0, y: -1 };
            break;
          case 'ArrowDown':
            pacman.nextDirection = { x: 0, y: 1 };
            break;
          case 'ArrowLeft':
            pacman.nextDirection = { x: -1, y: 0 };
            break;
          case 'ArrowRight':
            pacman.nextDirection = { x: 1, y: 0 };
            break;
          case ' ':  // Space bar
            togglePause();
            break;
          case '+':
          case '=':
            changeSpeed(1);
            break;
          case '-':
          case '_':
            changeSpeed(-1);
            break;
        }
      } else if (gamePaused && e.key === ' ') {
        togglePause();
      }
    });
    
    // Start the game
    initGame();
  </script>
</body>
</html>
