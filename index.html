<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Joystick Pacman</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Press Start 2P', cursive, Arial, sans-serif;
    }
    
    #game-container {
      position: relative;
      margin: 20px auto;
      width: 800px;
      height: 600px;
    }
    
    #canvas {
      display: block;
      margin: 0 auto;
      background-color: #000;
    }
    
    #connect {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 16px;
      font-size: 16px;
      z-index: 10;
      background-color: #FFD700;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
    }
    
    #connect:hover {
      background-color: #FFC107;
    }
    
    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #life {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 30px;
      z-index: 5;
    }
    
    #controls {
      position: fixed;
      top: 20px;
      right: 10px;
      color: #FFD700;
      z-index: 10;
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 5px;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 10px;
      border-radius: 5px;
    }
    
    .control-group {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .control-label {
      font-size: 16px;
    }
    
    .control-btn {
      padding: 5px 10px;
      background-color: #FFD700;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
      font-size: 12px;
    }
    
    .control-btn:hover {
      background-color: #FFC107;
    }
    
    #pause-btn {
      padding: 5px 10px;
      background-color: #FFD700;
      border: none;
      border-radius: 3px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
      font-size: 14px;
      margin-top: 5px;
    }
    
    #message {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 36px;
      z-index: 15;
      text-align: center;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 20px;
      border-radius: 10px;
      display: none;
    }
    
    #debug {
      position: fixed;
      bottom: 20px;
      right: 10px;
      color: #FFD700;
      font-size: 12px;
      z-index: 10;
      text-align: right;
      font-family: monospace;
      background-color: rgba(0, 0, 0, 0.7);
      padding: 5px;
      border-radius: 3px;
      display: none;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <div id="game-container">
    <div id="score">Score: 0</div>
    <div id="life">Lives: 3</div>
    <div id="loading">Loading...</div>
    <div id="message">Paused<br><span style="font-size: 18px">Press Pause or Joystick Button to Resume</span></div>
    <canvas id="canvas" width="800" height="600"></canvas>
  </div>
  
  <div id="controls">
    <div class="control-group">
      <span class="control-label">Speed:</span>
      <button class="control-btn" id="speed-down">-</button>
      <span id="speed-value">Normal</span>
      <button class="control-btn" id="speed-up">+</button>
    </div>
    <button id="pause-btn">Pause</button>
  </div>
  
  <div id="debug">Joystick: X: 0.00, Y: 0.00<br>Direction: none</div>

  <script>
    // Game canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const lifeElement = document.getElementById('life');
    const loadingElement = document.getElementById('loading');
    const messageElement = document.getElementById('message');
    const speedValueElement = document.getElementById('speed-value');
    
    // Game state
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let gameOver = false;
    let gamePaused = false;
    let debugMode = true;  // Enable debug display
    
    // Ghost stuck detection
    const ghostStuckDetection = {
      checkInterval: 100, // Check every 100 frames
      counter: 0,
      lastPositions: []
    };
    
    // Frame rate control
    const TARGET_FPS = 60;  // Increased from 30 to 60 for smoother gameplay
    let lastFrameTime = 0;
    const MIN_FRAME_TIME = 1000 / TARGET_FPS;
    
    // Speed control
    const speedLevels = [
      { name: "Very Slow", factor: 0.5 },
      { name: "Slow", factor: 0.75 },
      { name: "Normal", factor: 1.0 },
      { name: "Fast", factor: 1.25 },
      { name: "Very Fast", factor: 1.5 }
    ];
    let currentSpeedIndex = 2; // Start at Normal speed
    let speedFactor = speedLevels[currentSpeedIndex].factor;
    
    // Base speeds that will be multiplied by the speed factor
    const BASE_PACMAN_SPEED = 3.5;  // Increased from 2.0 to 3.5
    const BASE_GHOST_SPEEDS = [4.0, 4.0, 3.8, 3.8];  // Increased ghost speeds further
    
    // Joystick variables
    let joystickX = 0, joystickY = 0;
    let joystickButton = 0;
    let joystickDirection = { x: 0, y: 0 };
    let reader;
    let buffer = '';
    
    // Sound effects
    const audioPaths = {
      chomp: 'sounds/PacManAdvancedSounds/3_soundFood.wav',
      death: 'sounds/PacManAdvancedSounds/1_soundDead.wav',
      eatGhost: 'sounds/PacManAdvancedSounds/2_soundGhost.wav',
      powerPill: 'sounds/PacManAdvancedSounds/4_soundPower.wav',
      win: 'sounds/PacManAdvancedSounds/5_soundWin.wav', // Added win sound
      start: 'sounds/pacman_beginning.mp3'
    };
    
    const sounds = {};
    
    // Pacman properties
    const pacman = {
      x: 400,
      y: 300,
      radius: 16,  // Reduced from 20 to 16 to fit through narrower corridors
      speed: BASE_PACMAN_SPEED,
      angle: 0,
      direction: { x: 1, y: 0 },
      nextDirection: { x: 1, y: 0 },
      mouthOpen: 0,
      mouthSpeed: 0.06  // Increased from 0.02 to 0.06 for faster animation
    };
    
    // Create maze walls - simplified for this demo
    const walls = [
      // Outer walls
      { x: 0, y: 0, width: 800, height: 40 },
      { x: 0, y: 560, width: 800, height: 40 },
      { x: 0, y: 0, width: 40, height: 600 },
      { x: 760, y: 0, width: 40, height: 600 },
      
      // Inner walls - horizontal
      { x: 120, y: 120, width: 200, height: 40 },
      { x: 400, y: 120, width: 280, height: 40 },
      { x: 120, y: 240, width: 160, height: 40 }, // Modified width to create path
      { x: 400, y: 240, width: 280, height: 40 },
      { x: 120, y: 360, width: 560, height: 40 },
      { x: 120, y: 480, width: 160, height: 40 }, // Modified width to create path
      { x: 400, y: 480, width: 280, height: 40 },
      
      // Inner walls - vertical
      { x: 120, y: 120, width: 40, height: 400 },
      { x: 280, y: 120, width: 40, height: 120 }, // Modified height to create path
      { x: 400, y: 120, width: 40, height: 120 }, // Modified height to create path
      { x: 640, y: 120, width: 40, height: 120 }, // Modified height to create path
      { x: 280, y: 400, width: 40, height: 120 }, // Modified y-position to create path
      { x: 400, y: 400, width: 40, height: 120 }, // Modified y-position to create path
      { x: 640, y: 400, width: 40, height: 120 }  // Modified y-position to create path
    ];
    
    // Dots for Pacman to eat
    let dots = [];
    const dotSize = 6;
    const dotSpacing = 40;
    
    // Ghosts
    const ghosts = [
      { x: 120, y: 120, color: 'red', speed: BASE_GHOST_SPEEDS[0], direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 120, color: 'pink', speed: BASE_GHOST_SPEEDS[1], direction: { x: -1, y: 0 }, state: 'normal' },
      { x: 120, y: 480, color: 'cyan', speed: BASE_GHOST_SPEEDS[2], direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 480, color: 'orange', speed: BASE_GHOST_SPEEDS[3], direction: { x: -1, y: 0 }, state: 'normal' }
    ];
    
    // Power pills
    const powerPills = [
      { x: 80, y: 80, radius: 10, active: true },
      { x: 720, y: 80, radius: 10, active: true },
      { x: 80, y: 520, radius: 10, active: true },
      { x: 720, y: 520, radius: 10, active: true }
    ];
    
    // Create dots throughout the maze
    function createDots() {
      dots = [];
      for (let x = 60; x < canvas.width; x += dotSpacing) {
        for (let y = 60; y < canvas.height; y += dotSpacing) {
          // Check if the dot is inside a wall
          let insideWall = false;
          
          for (const wall of walls) {
            if (
              x >= wall.x && 
              x <= wall.x + wall.width && 
              y >= wall.y && 
              y <= wall.y + wall.height
            ) {
              insideWall = true;
              break;
            }
          }
          
          // Only add dots that are not inside walls
          if (!insideWall) {
            dots.push({ x, y, active: true });
          }
        }
      }
    }

    // Generate a random direction for ghosts
    function getRandomDirection() {
      const directions = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];
      return directions[Math.floor(Math.random() * directions.length)];
    }
    
    // Check collision between circles (for Pacman-ghost collision)
    function circleCollision(circle1, circle2, radius1, radius2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < radius1 + radius2;
    }
    
    // Collision detection between circle and rectangle
    function circleRectCollision(circle, rect, radius) {
        // Find the closest point to the circle within the rectangle
        let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
        let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
        
        // Calculate the distance between the circle's center and this closest point
        let distanceX = circle.x - closestX;
        let distanceY = circle.y - closestY;
        
        // If the distance is less than the circle's radius, an intersection occurs
        let distanceSquared = (distanceX * distanceX) + (distanceY * distanceY);
        return distanceSquared < (radius * radius);
    }
    
    // Update direction based on joystick input
    function updateJoystickDirection(x, y) {
      // Update debug display with the current joystick values (only if debug element exists)
      const debugElement = document.getElementById('debug');
      if (debugElement) {
        debugElement.innerHTML = 
            `Joystick: X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}<br>` +
            `Direction: ${JSON.stringify(pacman.direction).replace(/[{}"]/g, '')}`;
      }
      
      // Use a smaller threshold for more responsive controls
      const threshold = 0.15;
      
      // Determine direction from joystick input with priority given to larger axis
      // X-axis is reversed: positive X means LEFT, negative X means RIGHT
      if (Math.abs(x) > Math.abs(y)) {
          // X-axis movement is dominant
          if (x > threshold) {
              pacman.nextDirection = { x: -1, y: 0 }; // Reversed: right stick = left movement
          } else if (x < -threshold) {
              pacman.nextDirection = { x: 1, y: 0 };  // Reversed: left stick = right movement
          }
      } else if (Math.abs(y) > Math.abs(x)) {
          // Y-axis movement is dominant
          if (y > threshold) {
              pacman.nextDirection = { x: 0, y: 1 };
          } else if (y < -threshold) {
              pacman.nextDirection = { x: 0, y: -1 };
          }
      }
    }
    
    // Move Pacman
    function movePacman() {
      if (gameRunning === false || gamePaused || gameOver) return;
      
      // Check if Pacman can turn at the current position
      if (pacman.nextDirection && (pacman.nextDirection.x !== pacman.direction.x || pacman.nextDirection.y !== pacman.direction.y)) {
          // Calculate test position with a small offset to allow earlier turns
          let testX = pacman.x;
          let testY = pacman.y;
          
          // Add turn anticipation for more responsive controls
          const turnOffset = speedFactor * 5;
          
          // Apply offset based on next direction to test
          testX += pacman.nextDirection.x * turnOffset;
          testY += pacman.nextDirection.y * turnOffset;
          
          // Test if we can move in the next direction from this position
          let canTurn = true;
          
          // Calculate the next position
          let nextX = testX + pacman.nextDirection.x * speedFactor * BASE_PACMAN_SPEED;
          let nextY = testY + pacman.nextDirection.y * speedFactor * BASE_PACMAN_SPEED;
          
          // Check for wall collisions in the new direction
          for (let wall of walls) {
              if (circleRectCollision(
                  { x: nextX, y: nextY }, wall, pacman.radius)) {
                  canTurn = false;
                  break;
              }
          }
          
          // If we can turn, update the direction immediately
          if (canTurn) {
              pacman.direction = pacman.nextDirection;
          }
      }
      
      // Move Pacman in the current direction
      let speedX = pacman.direction.x * speedFactor * BASE_PACMAN_SPEED;
      let speedY = pacman.direction.y * speedFactor * BASE_PACMAN_SPEED;
      
      // Test if the next position is valid (no wall collision)
      let nextX = pacman.x + speedX;
      let nextY = pacman.y + speedY;
      let canMove = true;
      
      for (let wall of walls) {
          if (circleRectCollision(
              { x: nextX, y: nextY }, wall, pacman.radius)) {
              canMove = false;
              break;
          }
      }
      
      // Move if no collision
      if (canMove) {
          pacman.x = nextX;
          pacman.y = nextY;
      }
      
      // Check for dot collision and eating
      checkDotCollision();
      
      // Check for power pellet collision
      checkPowerPelletCollision();
      
      // Check for ghost collision
      checkGhostCollision();
    }
    
    // Move ghosts
    function moveGhosts() {
      if (!gameRunning || gamePaused || gameOver) return;
      
      for (const ghost of ghosts) {
        // Reduce vulnerable timer if vulnerable
        if (ghost.state === 'vulnerable' && ghost.vulnerableTimer > 0) {
          ghost.vulnerableTimer--;
          if (ghost.vulnerableTimer === 0) {
            ghost.state = 'normal';
          }
        }
        
        // Decide whether to chase Pacman or move randomly
        // Increasing the probability to make direction decisions to 15%
        if (ghost.state === 'normal' && Math.random() < 0.15) {  // Increased from 0.05 to 0.15 for more frequent direction changes
          // 90% chance to chase Pacman, 10% chance for random movement
          if (Math.random() < 0.9) {  // Increased from 0.8 to 0.9 to make ghosts even more aggressive
            // Chase Pacman - determine best direction to move towards Pacman
            let bestDirection = { x: 0, y: 0 };
            
            // Calculate direction to Pacman
            const dx = pacman.x - ghost.x;
            const dy = pacman.y - ghost.y;
            
            // Choose primary direction based on distance
            if (Math.abs(dx) > Math.abs(dy)) {
              // Horizontal distance is greater
              bestDirection.x = dx > 0 ? 1 : -1;
              bestDirection.y = 0;
            } else {
              // Vertical distance is greater
              bestDirection.x = 0;
              bestDirection.y = dy > 0 ? 1 : -1;
            }
            
            // Check if the best direction is blocked by a wall
            let nextX = ghost.x + bestDirection.x * ghost.speed * speedFactor;
            let nextY = ghost.y + bestDirection.y * ghost.speed * speedFactor;
            let bestDirectionBlocked = false;
            
            for (const wall of walls) {
              if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
                bestDirectionBlocked = true;
                break;
              }
            }
            
            // If the best direction is blocked, try the alternate axis
            if (bestDirectionBlocked) {
              if (bestDirection.x !== 0) {
                // Try vertical axis
                bestDirection.x = 0;
                bestDirection.y = dy > 0 ? 1 : -1;
              } else {
                // Try horizontal axis
                bestDirection.y = 0;
                bestDirection.x = dx > 0 ? 1 : -1;
              }
              
              // Check if alternate direction is also blocked
              nextX = ghost.x + bestDirection.x * ghost.speed * speedFactor;
              nextY = ghost.y + bestDirection.y * ghost.speed * speedFactor;
              let alternateBlocked = false;
              
              for (const wall of walls) {
                if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
                  alternateBlocked = true;
                  break;
                }
              }
              
              // If alternate is also blocked, just pick a random valid direction
              if (alternateBlocked) {
                let validDirectionFound = false;
                let attemptsCount = 0;
                
                while (!validDirectionFound && attemptsCount < 4) {
                  attemptsCount++;
                  const randomDir = getRandomDirection();
                  
                  nextX = ghost.x + randomDir.x * ghost.speed * speedFactor;
                  nextY = ghost.y + randomDir.y * ghost.speed * speedFactor;
                  
                  let isBlocked = false;
                  for (const wall of walls) {
                    if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
                      isBlocked = true;
                      break;
                    }
                  }
                  
                  if (!isBlocked) {
                    bestDirection = randomDir;
                    validDirectionFound = true;
                  }
                }
              }
            }
            
            ghost.direction = bestDirection;
          } else {
            // Random movement
            ghost.direction = getRandomDirection();
          }
        } else if (ghost.state === 'vulnerable' && Math.random() < 0.12) {  // Increased from 0.08 to 0.12
          // When vulnerable, try to move away from Pacman
          const dx = pacman.x - ghost.x;
          const dy = pacman.y - ghost.y;
          
          // Choose direction away from Pacman
          if (Math.abs(dx) > Math.abs(dy)) {
            ghost.direction = { x: dx > 0 ? -1 : 1, y: 0 };
          } else {
            ghost.direction = { x: 0, y: dy > 0 ? -1 : 1 };
          }
        }
        
        // Apply speed factor to ghost movement
        const adjustedSpeed = ghost.speed * speedFactor * (ghost.state === 'vulnerable' ? 0.5 : 1);
        
        // Move ghost with the adjusted speed
        let nextX = ghost.x + ghost.direction.x * adjustedSpeed;
        let nextY = ghost.y + ghost.direction.y * adjustedSpeed;
        
        // Check for wall collisions
        let hitWall = false;
        for (const wall of walls) {
          if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
            hitWall = true;
            break;
          }
        }
        
        if (hitWall) {
          // Change direction if hit a wall
          // Try multiple directions until finding a valid one
          let foundValidDirection = false;
          let attempts = 0;
          const maxAttempts = 4;  // Try all four directions
          
          while (!foundValidDirection && attempts < maxAttempts) {
            attempts++;
            ghost.direction = getRandomDirection();
            
            nextX = ghost.x + ghost.direction.x * adjustedSpeed;
            nextY = ghost.y + ghost.direction.y * adjustedSpeed;
            
            // Check if the new direction is valid
            let validDirection = true;
            for (const wall of walls) {
              if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
                validDirection = false;
                break;
              }
            }
            
            if (validDirection) {
              foundValidDirection = true;
            }
          }
          
          // If all directions are blocked, just stay put for this frame
          if (!foundValidDirection) {
            nextX = ghost.x;
            nextY = ghost.y;
          }
        } else {
          ghost.x = nextX;
          ghost.y = nextY;
          
          // Handle screen wrapping
          if (ghost.x < -20) ghost.x = canvas.width + 20;
          if (ghost.x > canvas.width + 20) ghost.x = -20;
          if (ghost.y < -20) ghost.y = canvas.height + 20;
          if (ghost.y > canvas.height + 20) ghost.y = -20;
        }
        
        // Check for collision with Pacman
        if (circleCollision(pacman, ghost, pacman.radius - 5, pacman.radius - 5)) {
          if (ghost.state === 'vulnerable') {
            // Pacman eats ghost
            ghost.x = 400;
            ghost.y = 300;
            ghost.state = 'normal';
            score += 200;
            scoreElement.textContent = `Score: ${score}`;
            playSound('eatGhost');
          } else if (ghost.state === 'normal') {
            // Ghost catches Pacman
            lives--;
            lifeElement.textContent = `Lives: ${lives}`;
            playSound('death');
            
            if (lives <= 0) {
              gameOver = true;
            } else {
              // Reset positions
              resetPositions();
            }
          }
        }
      }
    }
    
    // Reset positions after losing a life
    function resetPositions() {
      pacman.x = 400;
      pacman.y = 300;
      pacman.direction = { x: 1, y: 0 };
      pacman.nextDirection = { x: 1, y: 0 };
      
      // Reset ghost positions and directions with better starting positions
      ghosts[0].x = 120;
      ghosts[0].y = 120;
      ghosts[0].direction = { x: 1, y: 0 };
      ghosts[0].state = 'normal';
      
      ghosts[1].x = 680;
      ghosts[1].y = 120;
      ghosts[1].direction = { x: -1, y: 0 };
      ghosts[1].state = 'normal';
      
      ghosts[2].x = 120;
      ghosts[2].y = 480;
      ghosts[2].direction = { x: 1, y: 0 };
      ghosts[2].state = 'normal';
      
      ghosts[3].x = 680;
      ghosts[3].y = 480;
      ghosts[3].direction = { x: -1, y: 0 };
      ghosts[3].state = 'normal';
      
      // Short pause to acknowledge death
      gameRunning = false;
      setTimeout(() => {
        gameRunning = true;
        // No need to call gameLoop here since requestAnimationFrame is already running
      }, 1500);  // Increased from 1000 to 1500ms for a longer pause
    }
    
    // Draw the game
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw walls
      ctx.fillStyle = '#0000AA';
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      
      // Draw dots
      ctx.fillStyle = '#FFFF00';
      for (const dot of dots) {
        if (dot.active) {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw power pills
      ctx.fillStyle = '#FFFF00';
      for (const pill of powerPills) {
        if (pill.active) {
          ctx.beginPath();
          ctx.arc(pill.x, pill.y, pill.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw Pacman
      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();
      ctx.arc(
        pacman.x, 
        pacman.y, 
        pacman.radius, 
        pacman.angle + pacman.mouthOpen * Math.PI, 
        pacman.angle + (2 - pacman.mouthOpen) * Math.PI
      );
      ctx.lineTo(pacman.x, pacman.y);
      ctx.fill();
      
      // Draw ghosts
      for (const ghost of ghosts) {
        if (ghost.state === 'vulnerable') {
          // Blinking effect when vulnerability is about to end
          if (ghost.vulnerableTimer < 100 && Math.floor(ghost.vulnerableTimer / 10) % 2 === 0) {
            ctx.fillStyle = '#FFFFFF';
          } else {
            ctx.fillStyle = '#0000FF';
          }
        } else {
          ctx.fillStyle = ghost.color;
        }
        
        // Draw ghost body
        ctx.beginPath();
        ctx.arc(ghost.x, ghost.y, pacman.radius - 2, Math.PI, 0, false);
        ctx.lineTo(ghost.x + (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        
        // Draw the wavy bottom
        const segments = 3;
        const segmentWidth = (pacman.radius * 2 - 4) / segments;
        
        for (let i = 0; i < segments; i++) {
          const segX = ghost.x + (pacman.radius - 2) - (i * segmentWidth);
          ctx.arc(segX - (segmentWidth/2), ghost.y + (pacman.radius - 2), segmentWidth/2, 0, Math.PI, true);
        }
        
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y);
        ctx.fill();
        
        // Draw ghost eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(ghost.x - 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw pupils
        ctx.fillStyle = '#000000';
        const pupilX = ghost.direction.x * 2;
        const pupilY = ghost.direction.y * 2;
        
        ctx.beginPath();
        ctx.arc(ghost.x - 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw game over message
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '48px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText('Reconnect joystick to play again', canvas.width / 2, canvas.height / 2 + 90);
      }
      
      // Check if all dots are eaten
      const remainingDots = dots.filter(dot => dot.active).length;
      const remainingPills = powerPills.filter(pill => pill.active).length;
      
      if (remainingDots === 0 && remainingPills === 0) {
        // Level completed
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '36px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        if (!gameOver) {
          // Play win sound
          playSound('win');
          
          // Reset game for next level
          setTimeout(() => {
            createDots();
            for (const pill of powerPills) {
              pill.active = true;
            }
            resetPositions();
          }, 3000);
        }
      }
    }
    
    // Load and play sounds
    function loadSounds() {
      for (const [name, path] of Object.entries(audioPaths)) {
        sounds[name] = new Audio(path);
      }
    }
    
    function playSound(name) {
      if (sounds[name]) {
        // Stop the sound if it's currently playing
        sounds[name].pause();
        sounds[name].currentTime = 0;
        
        // Play the sound
        sounds[name].play().catch(error => {
          console.error(`Error playing sound ${name}:`, error);
        });
      }
    }
    
    // Main game loop
    function gameLoop(timestamp) {
      if (!gameRunning || gameOver || gamePaused) {
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Limit frame rate for more consistent speed
      const elapsed = timestamp - lastFrameTime;
      if (elapsed < MIN_FRAME_TIME) {
        requestAnimationFrame(gameLoop);
        return;
      }
      
      // Update last frame time
      lastFrameTime = timestamp;
      
      // Animate Pacman's mouth
      pacman.mouthOpen += pacman.mouthSpeed * speedFactor;
      if (pacman.mouthOpen <= 0 || pacman.mouthOpen >= 0.5) {
        pacman.mouthSpeed = -pacman.mouthSpeed;
      }
      
      // Set Pacman's angle based on direction
      if (pacman.direction.x === 1) pacman.angle = 0;
      else if (pacman.direction.x === -1) pacman.angle = Math.PI;
      else if (pacman.direction.y === -1) pacman.angle = -Math.PI/2;
      else if (pacman.direction.y === 1) pacman.angle = Math.PI/2;
      
      // Detect if ghosts are stuck
      ghostStuckDetection.counter++;
      if (ghostStuckDetection.counter >= ghostStuckDetection.checkInterval) {
        ghostStuckDetection.counter = 0;
        
        // Initialize last positions array if it's empty
        if (ghostStuckDetection.lastPositions.length === 0) {
          ghostStuckDetection.lastPositions = ghosts.map(ghost => ({
            x: ghost.x,
            y: ghost.y
          }));
        } else {
          // Check if ghosts have moved
          for (let i = 0; i < ghosts.length; i++) {
            const dx = Math.abs(ghosts[i].x - ghostStuckDetection.lastPositions[i].x);
            const dy = Math.abs(ghosts[i].y - ghostStuckDetection.lastPositions[i].y);
            
            // If ghost hasn't moved significantly
            if (dx < 5 && dy < 5) {
              // Ghost is stuck, give it a random direction
              ghosts[i].direction = getRandomDirection();
              
              // Move ghost a bit in the new direction to unstick it
              const unstickDistance = 10;
              ghosts[i].x += ghosts[i].direction.x * unstickDistance;
              ghosts[i].y += ghosts[i].direction.y * unstickDistance;
              
              // Ensure ghost is not inside a wall
              let insideWall = false;
              for (const wall of walls) {
                if (circleRectCollision(
                  { x: ghosts[i].x, y: ghosts[i].y }, 
                  wall, 
                  pacman.radius - 5
                )) {
                  insideWall = true;
                  break;
                }
              }
              
              // If still inside a wall, reset to a safe location
              if (insideWall) {
                // Reset to one of the four corners
                const safeLocations = [
                  { x: 120, y: 120 },
                  { x: 680, y: 120 },
                  { x: 120, y: 480 },
                  { x: 680, y: 480 }
                ];
                const randomIndex = Math.floor(Math.random() * safeLocations.length);
                ghosts[i].x = safeLocations[randomIndex].x;
                ghosts[i].y = safeLocations[randomIndex].y;
              }
            }
            
            // Update last position
            ghostStuckDetection.lastPositions[i] = {
              x: ghosts[i].x,
              y: ghosts[i].y
            };
          }
        }
      }
      
      updateJoystickDirection(joystickX, joystickY);
      movePacman();
      moveGhosts();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Function to change game speed
    function changeSpeed(direction) {
      // direction: 1 = faster, -1 = slower
      currentSpeedIndex = Math.max(0, Math.min(speedLevels.length - 1, currentSpeedIndex + direction));
      speedFactor = speedLevels[currentSpeedIndex].factor;
      speedValueElement.textContent = speedLevels[currentSpeedIndex].name;
      
      // Update debug display with new speed
      if (debugMode) {
        const debugElement = document.getElementById('debug');
        debugElement.innerHTML += `<br>Speed: ${speedLevels[currentSpeedIndex].name} (${speedFactor.toFixed(2)})`;
      }
    }
    
    // Touch and keyboard handlers
    function handleKeyDown(e) {
      if (gameRunning && !gamePaused) {
        switch (e.key) {
          case 'ArrowUp':
            pacman.nextDirection = { x: 0, y: -1 };
            break;
          case 'ArrowDown':
            pacman.nextDirection = { x: 0, y: 1 };
            break;
          case 'ArrowLeft':
            pacman.nextDirection = { x: -1, y: 0 };
            break;
          case 'ArrowRight':
            pacman.nextDirection = { x: 1, y: 0 };
            break;
          case ' ':  // Space bar
            togglePause();
            break;
          case '+':
          case '=':
            changeSpeed(1);
            break;
          case '-':
          case '_':
            changeSpeed(-1);
            break;
        }
      } else if (gamePaused && e.key === ' ') {
        togglePause();
      }
    }
    
    // Check for collision with dots
    function checkDotCollision() {
      for (let i = 0; i < dots.length; i++) {
        if (dots[i].active) {
          const distance = Math.sqrt(
            Math.pow(pacman.x - dots[i].x, 2) + 
            Math.pow(pacman.y - dots[i].y, 2)
          );
          
          if (distance < pacman.radius) {
            // Pacman eats the dot
            dots[i].active = false;
            score += 10;
            scoreElement.textContent = `Score: ${score}`;
            
            // Play chomp sound
            playSound('chomp');
          }
        }
      }
    }
    
    // Check for collision with power pills
    function checkPowerPelletCollision() {
      for (let i = 0; i < powerPills.length; i++) {
        if (powerPills[i].active) {
          const distance = Math.sqrt(
            Math.pow(pacman.x - powerPills[i].x, 2) + 
            Math.pow(pacman.y - powerPills[i].y, 2)
          );
          
          if (distance < pacman.radius + powerPills[i].radius) {
            // Pacman eats the power pill
            powerPills[i].active = false;
            score += 50;
            scoreElement.textContent = `Score: ${score}`;
            
            // Make ghosts vulnerable
            for (const ghost of ghosts) {
              ghost.state = 'vulnerable';
              ghost.vulnerableTimer = 300; // 10 seconds at 30fps
            }
            
            // Play power pill sound
            playSound('powerPill');
          }
        }
      }
    }
    
    // Check for collision with ghosts
    function checkGhostCollision() {
      for (const ghost of ghosts) {
        const distance = Math.sqrt(
          Math.pow(pacman.x - ghost.x, 2) + 
          Math.pow(pacman.y - ghost.y, 2)
        );
        
        if (distance < pacman.radius + (pacman.radius - 5)) {
          if (ghost.state === 'vulnerable') {
            // Pacman eats ghost
            ghost.x = 400;
            ghost.y = 300;
            ghost.state = 'normal';
            score += 200;
            scoreElement.textContent = `Score: ${score}`;
            playSound('eatGhost');
          } else if (ghost.state === 'normal') {
            // Ghost catches Pacman
            lives--;
            lifeElement.textContent = `Lives: ${lives}`;
            playSound('death');
            
            if (lives <= 0) {
              gameOver = true;
            } else {
              // Reset positions
              resetPositions();
            }
          }
        }
      }
    }
    
    function handleKeyUp(e) {
      // Currently not used, but included for completeness
    }
    
    function handleTouchStart(e) {
      // Touch controls implementation
      if (e.touches.length > 0) {
        const touch = e.touches[0];
        const touchX = touch.clientX;
        const touchY = touch.clientY;
        
        // Determine which direction to move based on touch position
        const rect = canvas.getBoundingClientRect();
        const centerX = rect.left + rect.width / 2;
        const centerY = rect.top + rect.height / 2;
        
        if (Math.abs(touchX - centerX) > Math.abs(touchY - centerY)) {
          // Horizontal swipe
          if (touchX > centerX) {
            pacman.nextDirection = { x: 1, y: 0 };
          } else {
            pacman.nextDirection = { x: -1, y: 0 };
          }
        } else {
          // Vertical swipe
          if (touchY > centerY) {
            pacman.nextDirection = { x: 0, y: 1 };
          } else {
            pacman.nextDirection = { x: 0, y: -1 };
          }
        }
      }
      
      e.preventDefault();
    }
    
    function handleTouchMove(e) {
      // Prevent scrolling
      e.preventDefault();
    }
    
    function handleTouchEnd(e) {
      // Currently not used, but included for completeness
      e.preventDefault();
    }
    
    // Initialize the game
    function init() {
      createDots();
      loadSounds();
      
      // Set up initial positions
      resetPositions();
      
      // Hide loading screen
      loadingElement.style.display = 'none';
      
      // Make sure the game elements are visible and the canvas is accessible
      canvas.style.display = 'block';
      
      // Draw initial state
      draw();
      
      // Start the game loop with game properly running
      gameRunning = true;
      gamePaused = false;
      gameOver = false;
      lastFrameTime = Date.now();
      
      // Force the first frame to run immediately
      const initialTimestamp = Date.now();
      gameLoop(initialTimestamp);
      
      // Set up input event listeners
      document.addEventListener('keydown', handleKeyDown);
      document.addEventListener('keyup', handleKeyUp);
      document.addEventListener('touchstart', handleTouchStart);
      document.addEventListener('touchmove', handleTouchMove);
      document.addEventListener('touchend', handleTouchEnd);
      
      // Add connect button for Arduino joystick
      addConnectButton();
      
      // Trigger initial resize to set correct dimensions
      window.dispatchEvent(new Event('resize'));
      
      // Play start sound
      playSound('start');
    }
    
    // Function to read and process serial data from Arduino
    function readSerialData(data) {
        // Parse CSV format: "X,Y,BUTTON"
        const values = data.trim().split(',');
        if (values.length >= 3) {
            // Parse joystick values (0-1023 from Arduino)
            const rawX = parseInt(values[0]);
            const rawY = parseInt(values[1]);
            const buttonState = parseInt(values[2]);
            
            // Check if values are valid numbers
            if (!isNaN(rawX) && !isNaN(rawY) && !isNaN(buttonState)) {
                // Normalize joystick values to range -1 to 1
                let x = (rawX - 512) / 512;
                let y = (rawY - 512) / 512;
                
                // Flip Y axis if needed
                y = -y;
                
                // Apply smaller deadzone
                const deadzone = 0.08; // Reduced from 0.1 for more sensitivity
                if (Math.abs(x) < deadzone) x = 0;
                if (Math.abs(y) < deadzone) y = 0;
                
                // Apply non-linear scaling for better control
                x = Math.sign(x) * Math.pow(Math.abs(x), 0.8);
                y = Math.sign(y) * Math.pow(Math.abs(y), 0.8);
                
                // Update global joystick values
                joystickX = x;
                joystickY = y;
                
                // Handle button press - toggle pause
                if (buttonState === 1 && !buttonPressed) {
                    togglePause();
                    buttonPressed = true;
                } else if (buttonState === 0) {
                    buttonPressed = false;
                }
                
                // Update debug display if it exists
                const debugElement = document.getElementById('joystick-debug');
                if (debugElement) {
                    debugElement.textContent = `X: ${x.toFixed(2)}, Y: ${y.toFixed(2)}, Btn: ${buttonState}`;
                }
            }
        }
    }

    // WebSerial API initialization
    let port;
    let buttonPressed = false;

    async function connectToArduino() {
        try {
            port = await navigator.serial.requestPort();
            await port.open({ baudRate: 9600 });
            
            const reader = port.readable.getReader();
            const textDecoder = new TextDecoder();
            let buffer = '';
            
            // Read data loop
            while (true) {
                const { value, done } = await reader.read();
                if (done) break;
                
                // Decode the received bytes
                const chunk = textDecoder.decode(value);
                buffer += chunk;
                
                // Process complete lines
                const lines = buffer.split('\n');
                buffer = lines.pop(); // Keep the incomplete line in the buffer
                
                // Process each complete line
                for (const line of lines) {
                    if (line.trim()) {
                        readSerialData(line);
                    }
                }
            }
        } catch (error) {
            console.error('Serial connection error:', error);
        }
    }

    // Add a connect button to the UI
    function addConnectButton() {
        // Remove existing connect button and debug display if they exist
        const existingButton = document.getElementById('connect-button');
        if (existingButton) {
            existingButton.remove();
        }
        
        const existingDebug = document.getElementById('joystick-debug');
        if (existingDebug) {
            existingDebug.remove();
        }
        
        const connectButton = document.createElement('button');
        connectButton.id = 'connect-button';
        connectButton.textContent = 'Connect Joystick';
        connectButton.style.position = 'absolute';
        connectButton.style.top = '10px';
        connectButton.style.left = '10px';
        connectButton.style.padding = '10px';
        connectButton.style.zIndex = '1000';
        connectButton.style.backgroundColor = '#4CAF50';
        connectButton.style.color = 'white';
        connectButton.style.border = 'none';
        connectButton.style.borderRadius = '5px';
        connectButton.style.cursor = 'pointer';
        connectButton.addEventListener('click', connectToArduino);
        document.body.appendChild(connectButton);
        
        // Add a joystick debug display
        const joystickDebug = document.createElement('div');
        joystickDebug.id = 'joystick-debug';
        joystickDebug.style.position = 'absolute';
        joystickDebug.style.top = '60px';
        joystickDebug.style.left = '10px';
        joystickDebug.style.color = 'white';
        joystickDebug.style.fontFamily = 'monospace';
        joystickDebug.style.zIndex = '1000';
        document.body.appendChild(joystickDebug);
    }

    // Handle window resize
    window.addEventListener('resize', () => {
      // Keep the game proportional
      const container = document.getElementById('game-container');
      const aspectRatio = canvas.width / canvas.height;
      
      let newWidth = window.innerWidth * 0.8;
      let newHeight = newWidth / aspectRatio;
      
      if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight * aspectRatio;
      }
      
      container.style.width = `${newWidth}px`;
      container.style.height = `${newHeight}px`;
    });
    
    // Function to toggle game pause state
    function togglePause() {
      gamePaused = !gamePaused;
      
      if (gamePaused) {
        messageElement.style.display = 'block';
      } else {
        messageElement.style.display = 'none';
        // Restart the game loop if unpausing
        if (gameRunning && !gameOver) {
          gameLoop();
        }
      }
    }
    
    // Set up control buttons
    document.getElementById('speed-up').addEventListener('click', () => changeSpeed(1));
    document.getElementById('speed-down').addEventListener('click', () => changeSpeed(-1));
    document.getElementById('pause-btn').addEventListener('click', togglePause);
    
    // Add keyboard controls for testing without Arduino
    window.addEventListener('keydown', handleKeyDown);
    
    // Start the game
    init();
  </script>
</body>
</html>
