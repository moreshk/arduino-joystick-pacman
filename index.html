<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>Joystick Pacman</title>
  <style>
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      background-color: #000;
      font-family: 'Press Start 2P', cursive, Arial, sans-serif;
    }
    
    #game-container {
      position: relative;
      margin: 20px auto;
      width: 800px;
      height: 600px;
    }
    
    #canvas {
      display: block;
      margin: 0 auto;
      background-color: #000;
    }
    
    #connect {
      position: absolute;
      top: 10px;
      left: 10px;
      padding: 8px 16px;
      font-size: 16px;
      z-index: 10;
      background-color: #FFD700;
      border: none;
      border-radius: 5px;
      cursor: pointer;
      color: #000;
      font-family: inherit;
    }
    
    #connect:hover {
      background-color: #FFC107;
    }
    
    #score {
      position: absolute;
      top: 10px;
      right: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #life {
      position: absolute;
      bottom: 10px;
      left: 10px;
      color: #FFD700;
      font-size: 24px;
      z-index: 10;
    }
    
    #loading {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: #FFD700;
      font-size: 30px;
      z-index: 5;
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <div id="game-container">
    <button id="connect">Connect Joystick</button>
    <div id="score">Score: 0</div>
    <div id="life">Lives: 3</div>
    <div id="loading">Loading...</div>
    <canvas id="canvas" width="800" height="600"></canvas>
  </div>

  <script>
    // Game canvas setup
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const scoreElement = document.getElementById('score');
    const lifeElement = document.getElementById('life');
    const loadingElement = document.getElementById('loading');
    
    // Game state
    let score = 0;
    let lives = 3;
    let gameRunning = false;
    let gameOver = false;
    
    // Joystick variables
    let joystickX = 0, joystickY = 0;
    let joystickDirection = { x: 0, y: 0 };
    let reader;
    let buffer = '';
    
    // Sound effects
    const audioPaths = {
      chomp: 'sounds/pacman_chomp.mp3',
      death: 'sounds/pacman_death.mp3',
      eatGhost: 'sounds/pacman_eatghost.mp3',
      eatFruit: 'sounds/pacman_eatfruit.mp3',
      powerPill: 'sounds/pacman_powerpill.mp3',
      start: 'sounds/pacman_beginning.mp3'
    };
    
    const sounds = {};
    
    // Pacman properties
    const pacman = {
      x: 400,
      y: 300,
      radius: 20,
      speed: 3,
      angle: 0,
      direction: { x: 1, y: 0 },
      nextDirection: { x: 1, y: 0 },
      mouthOpen: 0,
      mouthSpeed: 0.1
    };
    
    // Create maze walls - simplified for this demo
    const walls = [
      // Outer walls
      { x: 0, y: 0, width: 800, height: 40 },
      { x: 0, y: 560, width: 800, height: 40 },
      { x: 0, y: 0, width: 40, height: 600 },
      { x: 760, y: 0, width: 40, height: 600 },
      
      // Inner walls - horizontal
      { x: 120, y: 120, width: 200, height: 40 },
      { x: 400, y: 120, width: 280, height: 40 },
      { x: 120, y: 240, width: 200, height: 40 },
      { x: 400, y: 240, width: 280, height: 40 },
      { x: 120, y: 360, width: 560, height: 40 },
      { x: 120, y: 480, width: 200, height: 40 },
      { x: 400, y: 480, width: 280, height: 40 },
      
      // Inner walls - vertical
      { x: 120, y: 120, width: 40, height: 400 },
      { x: 280, y: 120, width: 40, height: 160 },
      { x: 400, y: 120, width: 40, height: 160 },
      { x: 640, y: 120, width: 40, height: 160 },
      { x: 280, y: 360, width: 40, height: 160 },
      { x: 400, y: 360, width: 40, height: 160 },
      { x: 640, y: 360, width: 40, height: 160 }
    ];
    
    // Dots for Pacman to eat
    let dots = [];
    const dotSize = 6;
    const dotSpacing = 40;
    
    // Ghosts
    const ghosts = [
      { x: 120, y: 120, color: 'red', speed: 2, direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 120, color: 'pink', speed: 2, direction: { x: -1, y: 0 }, state: 'normal' },
      { x: 120, y: 480, color: 'cyan', speed: 2, direction: { x: 1, y: 0 }, state: 'normal' },
      { x: 680, y: 480, color: 'orange', speed: 2, direction: { x: -1, y: 0 }, state: 'normal' }
    ];
    
    // Power pills
    const powerPills = [
      { x: 80, y: 80, radius: 10, active: true },
      { x: 720, y: 80, radius: 10, active: true },
      { x: 80, y: 520, radius: 10, active: true },
      { x: 720, y: 520, radius: 10, active: true }
    ];
    
    // Create dots throughout the maze
    function createDots() {
      dots = [];
      for (let x = 60; x < canvas.width; x += dotSpacing) {
        for (let y = 60; y < canvas.height; y += dotSpacing) {
          // Check if the dot is inside a wall
          let insideWall = false;
          
          for (const wall of walls) {
            if (
              x >= wall.x && 
              x <= wall.x + wall.width && 
              y >= wall.y && 
              y <= wall.y + wall.height
            ) {
              insideWall = true;
              break;
            }
          }
          
          // Only add dots that are not inside walls
          if (!insideWall) {
            dots.push({ x, y, active: true });
          }
        }
      }
    }

    // Generate a random direction for ghosts
    function getRandomDirection() {
      const directions = [
        { x: 1, y: 0 },
        { x: -1, y: 0 },
        { x: 0, y: 1 },
        { x: 0, y: -1 }
      ];
      return directions[Math.floor(Math.random() * directions.length)];
    }
    
    // Check collision between circles (for Pacman-ghost collision)
    function circleCollision(circle1, circle2, radius1, radius2) {
      const dx = circle1.x - circle2.x;
      const dy = circle1.y - circle2.y;
      const distance = Math.sqrt(dx * dx + dy * dy);
      return distance < radius1 + radius2;
    }
    
    // Check collision between circle and rectangle (for wall collisions)
    function circleRectCollision(circle, rect, radius) {
      // Find the closest point in the rectangle to the circle
      let closestX = Math.max(rect.x, Math.min(circle.x, rect.x + rect.width));
      let closestY = Math.max(rect.y, Math.min(circle.y, rect.y + rect.height));
      
      // Calculate the distance between the circle's center and the closest point
      const dx = circle.x - closestX;
      const dy = circle.y - closestY;
      const distance = Math.sqrt(dx * dx + dy * dy);
      
      // If the distance is less than the circle's radius, there is a collision
      return distance < radius;
    }
    
    // Update direction based on joystick input
    function updateJoystickDirection() {
      // Threshold to detect significant joystick movement
      const threshold = 0.3;
      
      // Reset the direction object
      joystickDirection = { x: 0, y: 0 };
      
      // Determine the direction based on joystick values
      if (Math.abs(joystickX) > Math.abs(joystickY)) {
        // Horizontal movement has priority
        if (joystickX > threshold) {
          joystickDirection.x = 1;
        } else if (joystickX < -threshold) {
          joystickDirection.x = -1;
        }
      } else {
        // Vertical movement has priority
        if (joystickY > threshold) {
          joystickDirection.y = 1;
        } else if (joystickY < -threshold) {
          joystickDirection.y = -1;
        }
      }
      
      // Update Pacman's next direction if joystick has input
      if (joystickDirection.x !== 0 || joystickDirection.y !== 0) {
        pacman.nextDirection = { ...joystickDirection };
      }
    }
    
    // Move Pacman
    function movePacman() {
      let nextX = pacman.x + pacman.direction.x * pacman.speed;
      let nextY = pacman.y + pacman.direction.y * pacman.speed;
      
      // Check if Pacman can move in the current direction
      let canMove = true;
      for (const wall of walls) {
        if (circleRectCollision(
          { x: nextX, y: nextY }, 
          wall, 
          pacman.radius - 1 // Slightly smaller to allow smoother movement
        )) {
          canMove = false;
          break;
        }
      }
      
      // If Pacman can move in the current direction, update position
      if (canMove) {
        pacman.x = nextX;
        pacman.y = nextY;
      } else {
        // If Pacman cannot move in the current direction, try to change to the next direction
        const newDirNextX = pacman.x + pacman.nextDirection.x * pacman.speed;
        const newDirNextY = pacman.y + pacman.nextDirection.y * pacman.speed;
        
        let canChangeDirection = true;
        for (const wall of walls) {
          if (circleRectCollision(
            { x: newDirNextX, y: newDirNextY }, 
            wall, 
            pacman.radius - 1
          )) {
            canChangeDirection = false;
            break;
          }
        }
        
        if (canChangeDirection) {
          pacman.direction = { ...pacman.nextDirection };
          pacman.x = newDirNextX;
          pacman.y = newDirNextY;
        }
      }
      
      // Update angle based on direction
      if (pacman.direction.x === 1) pacman.angle = 0;
      else if (pacman.direction.x === -1) pacman.angle = Math.PI;
      else if (pacman.direction.y === -1) pacman.angle = -Math.PI / 2;
      else if (pacman.direction.y === 1) pacman.angle = Math.PI / 2;
      
      // Update mouth animation
      pacman.mouthOpen += pacman.mouthSpeed;
      if (pacman.mouthOpen > 0.5 || pacman.mouthOpen < 0) {
        pacman.mouthSpeed = -pacman.mouthSpeed;
      }
      
      // Check for dot collisions
      for (let i = 0; i < dots.length; i++) {
        if (dots[i].active && circleCollision(pacman, dots[i], pacman.radius, dotSize)) {
          dots[i].active = false;
          score += 10;
          scoreElement.textContent = `Score: ${score}`;
          playSound('chomp');
        }
      }
      
      // Check for power pill collisions
      for (const pill of powerPills) {
        if (pill.active && circleCollision(pacman, pill, pacman.radius, pill.radius)) {
          pill.active = false;
          score += 50;
          scoreElement.textContent = `Score: ${score}`;
          playSound('powerPill');
          
          // Make ghosts vulnerable
          for (const ghost of ghosts) {
            ghost.state = 'vulnerable';
            ghost.vulnerableTimer = 500; // About 8 seconds at 60 FPS
          }
        }
      }
      
      // Handle screen wrapping
      if (pacman.x < -pacman.radius) pacman.x = canvas.width + pacman.radius;
      if (pacman.x > canvas.width + pacman.radius) pacman.x = -pacman.radius;
      if (pacman.y < -pacman.radius) pacman.y = canvas.height + pacman.radius;
      if (pacman.y > canvas.height + pacman.radius) pacman.y = -pacman.radius;
    }
    
    // Move ghosts
    function moveGhosts() {
      for (const ghost of ghosts) {
        // Reduce vulnerable timer if vulnerable
        if (ghost.state === 'vulnerable' && ghost.vulnerableTimer > 0) {
          ghost.vulnerableTimer--;
          if (ghost.vulnerableTimer === 0) {
            ghost.state = 'normal';
          }
        }
        
        // Occasionally change direction randomly
        if (Math.random() < 0.01) {
          ghost.direction = getRandomDirection();
        }
        
        // Move ghost
        let nextX = ghost.x + ghost.direction.x * (ghost.state === 'vulnerable' ? ghost.speed * 0.5 : ghost.speed);
        let nextY = ghost.y + ghost.direction.y * (ghost.state === 'vulnerable' ? ghost.speed * 0.5 : ghost.speed);
        
        // Check for wall collisions
        let hitWall = false;
        for (const wall of walls) {
          if (circleRectCollision({ x: nextX, y: nextY }, wall, pacman.radius - 5)) {
            hitWall = true;
            break;
          }
        }
        
        if (hitWall) {
          // Change direction if hit a wall
          ghost.direction = getRandomDirection();
        } else {
          ghost.x = nextX;
          ghost.y = nextY;
          
          // Handle screen wrapping
          if (ghost.x < -20) ghost.x = canvas.width + 20;
          if (ghost.x > canvas.width + 20) ghost.x = -20;
          if (ghost.y < -20) ghost.y = canvas.height + 20;
          if (ghost.y > canvas.height + 20) ghost.y = -20;
        }
        
        // Check for collision with Pacman
        if (circleCollision(pacman, ghost, pacman.radius - 5, pacman.radius - 5)) {
          if (ghost.state === 'vulnerable') {
            // Pacman eats ghost
            ghost.x = 400;
            ghost.y = 300;
            ghost.state = 'normal';
            score += 200;
            scoreElement.textContent = `Score: ${score}`;
            playSound('eatGhost');
          } else if (ghost.state === 'normal') {
            // Ghost catches Pacman
            lives--;
            lifeElement.textContent = `Lives: ${lives}`;
            playSound('death');
            
            if (lives <= 0) {
              gameOver = true;
            } else {
              // Reset positions
              resetPositions();
            }
          }
        }
      }
    }
    
    // Reset positions after losing a life
    function resetPositions() {
      pacman.x = 400;
      pacman.y = 300;
      pacman.direction = { x: 1, y: 0 };
      pacman.nextDirection = { x: 1, y: 0 };
      
      // Reset ghost positions
      ghosts[0].x = 120;
      ghosts[0].y = 120;
      
      ghosts[1].x = 680;
      ghosts[1].y = 120;
      
      ghosts[2].x = 120;
      ghosts[2].y = 480;
      
      ghosts[3].x = 680;
      ghosts[3].y = 480;
      
      // Short pause to acknowledge death
      gameRunning = false;
      setTimeout(() => {
        gameRunning = true;
        gameLoop();
      }, 1000);
    }
    
    // Draw the game
    function draw() {
      // Clear canvas
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Draw walls
      ctx.fillStyle = '#0000AA';
      for (const wall of walls) {
        ctx.fillRect(wall.x, wall.y, wall.width, wall.height);
      }
      
      // Draw dots
      ctx.fillStyle = '#FFFF00';
      for (const dot of dots) {
        if (dot.active) {
          ctx.beginPath();
          ctx.arc(dot.x, dot.y, dotSize, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw power pills
      ctx.fillStyle = '#FFFF00';
      for (const pill of powerPills) {
        if (pill.active) {
          ctx.beginPath();
          ctx.arc(pill.x, pill.y, pill.radius, 0, Math.PI * 2);
          ctx.fill();
        }
      }
      
      // Draw Pacman
      ctx.fillStyle = '#FFFF00';
      ctx.beginPath();
      ctx.arc(
        pacman.x, 
        pacman.y, 
        pacman.radius, 
        pacman.angle + pacman.mouthOpen * Math.PI, 
        pacman.angle + (2 - pacman.mouthOpen) * Math.PI
      );
      ctx.lineTo(pacman.x, pacman.y);
      ctx.fill();
      
      // Draw ghosts
      for (const ghost of ghosts) {
        if (ghost.state === 'vulnerable') {
          // Blinking effect when vulnerability is about to end
          if (ghost.vulnerableTimer < 100 && Math.floor(ghost.vulnerableTimer / 10) % 2 === 0) {
            ctx.fillStyle = '#FFFFFF';
          } else {
            ctx.fillStyle = '#0000FF';
          }
        } else {
          ctx.fillStyle = ghost.color;
        }
        
        // Draw ghost body
        ctx.beginPath();
        ctx.arc(ghost.x, ghost.y, pacman.radius - 2, Math.PI, 0, false);
        ctx.lineTo(ghost.x + (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        
        // Draw the wavy bottom
        const segments = 3;
        const segmentWidth = (pacman.radius * 2 - 4) / segments;
        
        for (let i = 0; i < segments; i++) {
          const segX = ghost.x + (pacman.radius - 2) - (i * segmentWidth);
          ctx.arc(segX - (segmentWidth/2), ghost.y + (pacman.radius - 2), segmentWidth/2, 0, Math.PI, true);
        }
        
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y + (pacman.radius - 2));
        ctx.lineTo(ghost.x - (pacman.radius - 2), ghost.y);
        ctx.fill();
        
        // Draw ghost eyes
        ctx.fillStyle = '#FFFFFF';
        ctx.beginPath();
        ctx.arc(ghost.x - 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5, ghost.y - 2, 4, 0, Math.PI * 2);
        ctx.fill();
        
        // Draw pupils
        ctx.fillStyle = '#000000';
        const pupilX = ghost.direction.x * 2;
        const pupilY = ghost.direction.y * 2;
        
        ctx.beginPath();
        ctx.arc(ghost.x - 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.arc(ghost.x + 5 + pupilX, ghost.y - 2 + pupilY, 2, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // Draw game over message
      if (gameOver) {
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '48px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('GAME OVER', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        ctx.font = '16px "Press Start 2P"';
        ctx.fillText('Reconnect joystick to play again', canvas.width / 2, canvas.height / 2 + 90);
      }
      
      // Check if all dots are eaten
      const remainingDots = dots.filter(dot => dot.active).length;
      const remainingPills = powerPills.filter(pill => pill.active).length;
      
      if (remainingDots === 0 && remainingPills === 0) {
        // Level completed
        ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        ctx.fillStyle = '#FFFF00';
        ctx.font = '36px "Press Start 2P"';
        ctx.textAlign = 'center';
        ctx.fillText('LEVEL COMPLETE!', canvas.width / 2, canvas.height / 2 - 24);
        
        ctx.font = '24px "Press Start 2P"';
        ctx.fillText(`Score: ${score}`, canvas.width / 2, canvas.height / 2 + 40);
        
        if (!gameOver) {
          // Reset game for next level
          setTimeout(() => {
            createDots();
            for (const pill of powerPills) {
              pill.active = true;
            }
            resetPositions();
          }, 3000);
        }
      }
    }
    
    // Load and play sounds
    function loadSounds() {
      for (const [name, path] of Object.entries(audioPaths)) {
        sounds[name] = new Audio(path);
      }
    }
    
    function playSound(name) {
      if (sounds[name]) {
        // Stop the sound if it's currently playing
        sounds[name].pause();
        sounds[name].currentTime = 0;
        
        // Play the sound
        sounds[name].play().catch(error => {
          console.error(`Error playing sound ${name}:`, error);
        });
      }
    }
    
    // Main game loop
    function gameLoop() {
      if (!gameRunning || gameOver) return;
      
      updateJoystickDirection();
      movePacman();
      moveGhosts();
      draw();
      
      requestAnimationFrame(gameLoop);
    }
    
    // Initialize the game
    function initGame() {
      createDots();
      loadSounds();
      
      // Start the game when assets are loaded
      window.addEventListener('load', () => {
        loadingElement.style.display = 'none';
        gameRunning = true;
        playSound('start');
        gameLoop();
      });
    }
    
    // — Ask user to pick the Arduino serial port —
    async function connectSerial() {
      try {
        const port = await navigator.serial.requestPort();
        await port.open({ baudRate: 9600 });
        const decoder = new TextDecoderStream();
        port.readable.pipeTo(decoder.writable);
        reader = decoder.readable.getReader();
        console.log('Serial port opened');
        
        // Reset game state for new game
        score = 0;
        lives = 3;
        gameOver = false;
        scoreElement.textContent = `Score: ${score}`;
        lifeElement.textContent = `Lives: ${lives}`;
        createDots();
        resetPositions();
        
        // Start reading serial data
        readSerialData();
        
        // If the game is not running, start it
        if (!gameRunning) {
          gameRunning = true;
          playSound('start');
          gameLoop();
        }
      } catch(err) {
        console.error('Serial connection failed:', err);
      }
    }
    document.getElementById('connect').addEventListener('click', connectSerial);

    // Handle serial data reading separately from animation loop
    async function readSerialData() {
      try {
        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            reader.releaseLock();
            break;
          }
          
          // Add to buffer and process complete lines
          buffer += value;
          const lines = buffer.split('\n');
          buffer = lines.pop(); // Keep the last incomplete line in buffer
          
          // Process complete lines
          for (const line of lines) {
            const trimmed = line.trim();
            if (trimmed) {
              const [xs, ys] = trimmed.split(',').map(Number);
              if (!isNaN(xs) && !isNaN(ys)) {
                // normalize to -1…1
                joystickX = (xs - 512) / 512;
                joystickY = (ys - 512) / 512;
                
                // Apply a deadzone to prevent small joystick noise
                if (Math.abs(joystickX) < 0.05) joystickX = 0;
                if (Math.abs(joystickY) < 0.05) joystickY = 0;
              }
            }
          }
        }
      } catch (error) {
        console.error('Error reading serial data:', error);
      }
    }
    
    // Handle window resize
    window.addEventListener('resize', () => {
      // Keep the game proportional
      const container = document.getElementById('game-container');
      const aspectRatio = canvas.width / canvas.height;
      
      let newWidth = window.innerWidth * 0.8;
      let newHeight = newWidth / aspectRatio;
      
      if (newHeight > window.innerHeight * 0.8) {
        newHeight = window.innerHeight * 0.8;
        newWidth = newHeight * aspectRatio;
      }
      
      container.style.width = `${newWidth}px`;
      container.style.height = `${newHeight}px`;
    });
    
    // Start the game
    initGame();
  </script>
</body>
</html>
